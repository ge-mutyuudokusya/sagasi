<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<title>URL探しアドベンチャー - 砂漠フィールド</title>
<style>
  :root { --ui:#0f172a; --text:#e5e7eb; --accent:#22d3ee; --accent2:#a78bfa; }
  html,body{height:100%;margin:0;background:#0b1020;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:.5rem;padding:8px;height:100svh;box-sizing:border-box}
  canvas{background:#12203a;border:2px solid #233a66;border-radius:16px;image-rendering:pixelated;max-width:100%;height:auto;touch-action:none}
  .hud{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;justify-content:center}
  .pill{border:1px solid #2e4474;border-radius:999px;padding:.25rem .6rem;font-size:.9rem;background:#0e1a33aa}
  .pill .key{display:inline-block;min-width:1.2rem;text-align:center;border:1px solid #64748b;border-radius:6px;padding:0 .3rem;margin:0 .2rem;background:#0b1222}
  .dialog{position:fixed;left:0;right:0;bottom:0;padding:12px 16px;background:#0b1222e6;border-top:2px solid #233a66;box-shadow:0 -10px 35px #0004}
  .dialog .name{font-weight:700;color:var(--accent)}
  .dialog .text{margin-top:6px;line-height:1.5}
  .dialog .hint{margin-top:6px;color:var(--accent2)}
  .panel{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:center}
    .btn{user-select:none;cursor:pointer;border:1px solid #fdfdfd;border-radius:12px;padding:.5rem .8rem;background:#ffffffaa}
  .btn:active{transform:translateY(1px)}
  .cluster{display:flex;gap:6px;align-items:center}
  .chip{border:1px dashed #475569;border-radius:8px;padding:.2rem .45rem;background:#0c1430}
  .chip.have{border-style:solid;background:#0f1d4d}
  .urlBox{margin-top:4px;padding:.6rem;border:1px solid #334155;border-radius:10px;background:#0c1430}
  .urlBox a{color:#8be9fd}
  /* モバイルUI */
  .mobile{position:fixed;inset:auto 0 8px 0;display:flex;justify-content:space-between;padding:0 8px;gap:8px;pointer-events:none}
  .stick, .act{pointer-events:auto}
  .stick{width:128px;height:128px;border-radius:50%;background:#0b1222aa;border:1px solid #334155;position:relative;touch-action:none}
  .knob{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:56px;height:56px;border-radius:50%;background:#101b36;border:2px solid #475569}
  .act{display:flex;gap:8px}
  .act .btn{min-width:64px}
  @media(min-width:900px){ .mobile{display:none} }
</style>
</head>
<audio id="bgm" src="インヴェンション13番.mp3" loop autoplay style="display:none"></audio>
<script>
  // BGM自動再生対策（ユーザー操作後に再生）
  document.addEventListener('DOMContentLoaded', function() {
    const bgm = document.getElementById('bgm');
    function playBgm() {
      bgm.volume = 0.5;
      bgm.play().catch(()=>{});
      document.removeEventListener('pointerdown', playBgm);
      document.removeEventListener('keydown', playBgm);
    }
    document.addEventListener('pointerdown', playBgm);
    document.addEventListener('keydown', playBgm);
  });

  // ヒントリセット：ページリロード時にヒントだけリセット
  window.addEventListener('beforeunload', function() {
    const SAVE_KEY = 'url-hunt-progress-v1';
    const progress = JSON.parse(localStorage.getItem(SAVE_KEY) || '{"pieces":{}}');
    progress.pieces = {};
    localStorage.setItem(SAVE_KEY, JSON.stringify(progress));
  });
</script>

<body>
  <div class="wrap">
    <canvas id="game" width="800" height="480"></canvas>

    <div class="hud">
      <span class="pill">移動 <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> / 矢印</span>
      <span class="pill">会話/決定 <span class="key">Space</span></span>
      <span class="pill">スキップ <span class="key">Enter</span></span>
      <span class="pill">走る <span class="key">Shift</span></span>
    </div>

    <div class="panel">
      <div class="cluster">集めたヒント:
        <span id="chip0" class="chip">1</span>
        <span id="chip1" class="chip">2</span>
        <span id="chip2" class="chip">3</span>
        <span id="chip3" class="chip">4</span>
      </div>
      <button id="reset" class="btn" title="進捗を初期化">進捗リセット</button>
    </div>

    <div id="unlock" class="urlBox" style="display:none"></div>
  </div>

  <div id="dialog" class="dialog" style="display:none">
    <div class="name" id="dName"></div>
    <div class="text" id="dText"></div>
    <div class="hint" id="dHint"></div>
  </div>

  <!-- モバイル操作 -->
  <div class="mobile">
    <div id="stick" class="stick"><div class="knob" id="knob"></div></div>
    <div class="act">
      <div id="btnTalk" class="btn">会話</div>
      <div id="btnRun" class="btn">走る</div>
    </div>
  </div>

<script>
(() => {
  // --- 基本セットアップ ---
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');

  // ピクセルアート風スケール維持
  function fitCanvas() {
    const scale = Math.min(window.innerWidth / cvs.width, (window.innerHeight-170) / cvs.height);
    cvs.style.width = Math.floor(cvs.width * scale) + 'px';
  }
  addEventListener('resize', fitCanvas); fitCanvas();

  // --- マップ（タイル） ---
  // 0=床,1=壁(岩),2=低木/砂丘,3=水(オアシス,遅い),4=看板,5=サボテン(通行不可)
  const mapW=40, mapH=24, T=20; // タイルサイズ20px
  const map = [];

  function fill(v){ for(let y=0;y<mapH;y++){ map[y]=[]; for(let x=0;x<mapW;x++){ map[y][x]=v; } } }

  function carveRect(x0,y0,x1,y1,v=0){ for(let y=y0;y<=y1;y++) for(let x=x0;x<=x1;x++) map[y][x]=v; }

  function ringWalls(){
    for(let y=0;y<mapH;y++){
      for(let x=0;x<mapW;x++){
        if(x===0||y===0||x===mapW-1||y===mapH-1) map[y][x]=1;
      }
    }
  }

  function placeOasis(cx,cy,r){
    for(let y=cy-r;y<=cy+r;y++){
      for(let x=cx-r;x<=cx+r;x++){
        const dx=x-cx, dy=y-cy;
        if(dx*dx+dy*dy<=r*r && x>1 && y>1 && x<mapW-1 && y<mapH-1){
          map[y][x]=3;
        }
      }
    }
  }

  function sprinkle(type, chance, bounds){
    const [x0,y0,x1,y1]=bounds||[1,1,mapW-2,mapH-2];
    for(let y=y0;y<=y1;y++){
      for(let x=x0;x<=x1;x++){
        if(map[y][x]===0 && Math.random()<chance) map[y][x]=type;
      }
    }
  }

  function genMap(){
    fill(0); // 砂地
    ringWalls(); // 外周は岩壁

    // 砂漠の“道”と広場
    carveRect(3,10,36,13,0);  // 横断する街道
    carveRect(6,6,16,17,0);   // 西のキャンプ地
    carveRect(22,6,34,17,0);  // 東の遺跡前広場

    // 岩地(壁)の断続塊で地形感
    for(let i=0;i<5;i++){
      const rx = 4 + i*6;
      carveRect(rx,4,rx+1,8,1);
      carveRect(rx+2,15,rx+3,19,1);
    }

    // オアシスと小池（移動遅延）
    placeOasis(20,8,3);
    placeOasis(30,15,2);

    // 砂丘/低木(2)を散りばめる（見た目用, 通行可）
    sprinkle(2, 0.06, [1,1,mapW-2,mapH-2]);

    // サボテン(5)を点在（通行不可）
    sprinkle(5, 0.025, [1,1,mapW-2,mapH-2]);

    // 通り道は確保（主要ルートを床に戻す）
    for(let x=1;x<mapW-1;x++){ map[11][x]=0; map[12][x]=0; } // 大通り
    for(let y=6;y<18;y++){ map[y][10]=0; map[y][29]=0; }     // 南北の道

    // 看板の設置
    map[11][8]=4;  // 西の看板
    map[8][29]=4;  // オアシス脇の看板
  }
  genMap();

  // --- プレイヤー ---
  const player = { x: T*6, y: T*12, r: 8, speed: 2.0 };
  const keys = {};
  addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; if([' ','enter'].includes(e.key.toLowerCase())) e.preventDefault(); });
  addEventListener('keyup',   e=>{ keys[e.key.toLowerCase()]=false; });

  // --- NPC 定義（位置だけ砂漠に合わせて変更。会話/断片はそのまま） ---
  const npcs = [
    { id:'elder', name:'隊商長', x:T*12, y:T*12, dialog:[
        'ここから先はあんまりおもしろくないかもしれない....',
    
      ], hintPiece:'https://'
    },
    { id:'dog', name:'砂犬', x:T*29, y:T*8, dialog:[
        'ワン（どこまでも終わりの見えないRPG...）'
      ], hintPiece:'ge-mutyuudokusya.github.io'
    },
    { id:'guard', name:'見張り', x:T*29, y:T*16, dialog:[
        'これ詰んでるんじゃないか？',
        
      ], hintPiece:'/sagasi/RPG'
    },
    { id:'kid', name:'商人', x:T*9, y:T*16, dialog:[
        '僕50フロアまで行ったよ！'
        
      ], hintPiece:'\RPG.html'
    },
  ];

  // --- 調べ物（インタラクト） ---
  const interactables = [
    { type:'sign', name:'看板', x:T*8,  y:T*11, text:'「詰んだ時はセーブ＆ロード」' },
    { type:'sign', name:'看板', x:T*29, y:T*8,  text:'「体力がない時は宿屋」' },
    { type:'glow', name:'砂丘の陰', x:T*33, y:T*6, text:'何にも考えないでプレイできる終わりのないゲーム！' },
  ];

  // 進捗（ローカル保存）
  const SAVE_KEY = 'url-hunt-progress-v1';
  const progress = JSON.parse(localStorage.getItem(SAVE_KEY) || '{"pieces":{}}');

  function save(){ localStorage.setItem(SAVE_KEY, JSON.stringify(progress)); updateChips(); checkUnlock(); }

  function addPiece(piece){
    progress.pieces[piece]=true;
    showToast('ヒントを手に入れた: ' + piece);
    save();
  }

  // --- UI: ダイアログ ---
  const dialogEl = document.getElementById('dialog');
  const dName = document.getElementById('dName');
  const dText = document.getElementById('dText');
  const dHint = document.getElementById('dHint');
  let dialogState = null; // {lines:[], idx:0}
  function openDialog(name, lines, hint){
    dName.textContent = name;
    dText.textContent = lines[0] || '';
    dHint.textContent = hint ? `（ヒントの断片を思い出した…）` : '';
    dialogEl.style.display='block';
    dialogState = { lines, idx:0 };
  }
  function advanceDialog(){
    if(!dialogState) return;
    dialogState.idx++;
    if(dialogState.idx >= dialogState.lines.length){
      closeDialog();
    } else {
      dText.textContent = dialogState.lines[dialogState.idx];
    }
  }
  function closeDialog(){ dialogEl.style.display='none'; dialogState=null; }

  // --- 近接判定 & 会話 ---
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  const TALK_RANGE = 24;

  function tryTalk(){
    // NPC優先
    let target = null;
    let minD = 1e9;
    for(const n of npcs){
      const d = dist(player, n);
      if(d < TALK_RANGE && d < minD){ minD=d; target=n; }
    }
    if(target){
      openDialog(target.name, target.dialog, target.hintPiece && !progress.pieces[target.hintPiece]);
      if(target.hintPiece && !progress.pieces[target.hintPiece]) addPiece(target.hintPiece);
      return;
    }
    // 看板など
    for(const it of interactables){
      const d = Math.hypot(player.x - it.x, player.y - it.y);
      if(d < TALK_RANGE){
        openDialog(it.name, [it.text], null);
        // 看板は対応する断片を自然に想起する演出だけ（実ドロップはNPCから）
        return;
      }
    }
    showToast('誰も近くにいない…');
  }

  addEventListener('keydown', e=>{
    if(e.key===' '){ tryTalk(); }
    else if(e.key==='Enter'){ advanceDialog(); }
  });

  // --- HUD: ヒント表示/解放 ---
  const chips = [0,1,2,3].map(i=>document.getElementById('chip'+i));
  const PIECES = ['https://','ge-mutyuudokusya.github.io','/sagasi/RPG','\RPG.html'];

  function updateChips(){
    PIECES.forEach((p,i)=>{
      chips[i].classList.toggle('have', !!progress.pieces[p]);
      chips[i].textContent = progress.pieces[p] ? p : (i+1);
    });
  }
  updateChips();

  const unlockBox = document.getElementById('unlock');
  function checkUnlock(){
    const all = PIECES.every(p=>progress.pieces[p]);
    if(all){
      const url = PIECES.join('');
      unlockBox.style.display='block';
      unlockBox.innerHTML = `
        <div>URLが解放されました！</div>
        <div><a href="https://ge-mutyuudokusya.github.io/sagasi/RPG\RPG.html" target="_blank" rel="noopener">→ https://ge-mutyuudokusya.github.io/sagasi/RPG\RPG.html</a></div>
  <small><button style="  background: #540050;color:#8be9fd; "><a href="島.html">次のステージに行く</a></button></small>
      `;
    } else {
      unlockBox.style.display='none';
      unlockBox.innerHTML='';
    }
  }
  checkUnlock();

  // リセット
  document.getElementById('reset').addEventListener('click', ()=>{
    localStorage.removeItem(SAVE_KEY);
    progress.pieces = {};
    updateChips(); checkUnlock();
    showToast('進捗をリセットしました');
  });

  // --- モバイル操作（仮想スティック/ボタン） ---
  const stick = document.getElementById('stick');
  const knob = document.getElementById('knob');
  const btnTalk = document.getElementById('btnTalk');
  const btnRun = document.getElementById('btnRun');
  let joy = {dx:0,dy:0,active:false}, runHold=false;

  function stickPoint(e){
    const r = stick.getBoundingClientRect();
    const x = (e.touches?e.touches[0].clientX:e.clientX) - r.left - r.width/2;
    const y = (e.touches?e.touches[0].clientY:e.clientY) - r.top - r.height/2;
    const mag = Math.hypot(x,y);
    const max = r.width/2 - 10;
    const m = mag>max ? max/mag : 1;
    const kx = x*m, ky = y*m;
    knob.style.transform = `translate(\${kx}px, \${ky}px)`;
    joy.dx = (kx/max); joy.dy = (ky/max);
    joy.active = true;
  }
  function stickEnd(){
    knob.style.transform = `translate(-50%,-50%)`;
    joy.dx=0; joy.dy=0; joy.active=false;
  }
  ['mousedown','mousemove','touchstart','touchmove'].forEach(ev=>{
    stick.addEventListener(ev, (e)=>{ e.preventDefault(); stickPoint(e); }, {passive:false});
  });
  ['mouseup','mouseleave','touchend','touchcancel'].forEach(ev=>{
    stick.addEventListener(ev, (e)=>{ e.preventDefault(); stickEnd(); }, {passive:false});
  });
  btnTalk.addEventListener('click', ()=>tryTalk());
  btnRun.addEventListener('pointerdown', ()=> runHold=true);
  btnRun.addEventListener('pointerup',   ()=> runHold=false);
  btnRun.addEventListener('pointerleave',()=> runHold=false);

  // --- トースト ---
  let toastT=0, toastMsg='';
  function showToast(msg){
    toastMsg = msg; toastT = 90; // 約1.5秒
  }
  function drawToast(){
    if(toastT<=0) return; toastT--;
    ctx.save();
    ctx.globalAlpha = Math.max(0, Math.min(1, toastT/90));
    const w = ctx.measureText ? Math.min(600, ctx.measureText(toastMsg).width+40) : 400;
    const x = cvs.width/2, y = 40;
    ctx.fillStyle = '#0b1222cc'; roundedRect(x-w/2, y-18, w, 36, 10, true);
    ctx.fillStyle = '#cbd5e1';
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='16px ui-sans-serif';
    ctx.fillText(toastMsg, x, y);
    ctx.restore();
  }

  // --- ゲームループ ---
  function update(){
    // 入力
    let vx=0, vy=0;
    if(keys['arrowleft']||keys['a']) vx-=1;
    if(keys['arrowright']||keys['d']) vx+=1;
    if(keys['arrowup']||keys['w']) vy-=1;
    if(keys['arrowdown']||keys['s']) vy+=1;
    if(joy.active){ vx+=joy.dx; vy+=joy.dy; }
    const mag = Math.hypot(vx,vy)||1;
    const run = keys['shift'] || runHold;
    const spd = player.speed * (run?1.6:1.0);
    let nx = player.x + (vx/mag)*spd;
    let ny = player.y + (vy/mag)*spd;

    // 速度低下（オアシス）
    const tx = Math.floor(nx/T), ty = Math.floor(ny/T);
    if(map[ty] && map[ty][tx]===3){ nx = player.x + (vx/mag)*(spd*0.5); ny = player.y + (vy/mag)*(spd*0.5); }

    // 衝突（岩壁・サボテン）
    if(!isWalkable(nx, player.y)) nx = player.x;
    if(!isWalkable(player.x, ny)) ny = player.y;

    player.x = nx; player.y = ny;
  }

  function isWalkable(px, py){
    const tx = Math.floor(px/T), ty = Math.floor(py/T);
    const v = (map[ty]||[])[tx];
    // 1=壁(岩),5=サボテン は通れない
    return v!==1 && v!==5;
  }

  function draw(){
    // 背景（砂漠パレット）
    ctx.clearRect(0,0,cvs.width,cvs.height);
    for(let y=0;y<mapH;y++){
      for(let x=0;x<mapW;x++){
        const v = map[y][x];
        // ベース色
        // 0 砂, 1 岩, 2 低木/砂丘, 3 水(オアシス), 4 看板, 5 サボテン
        ctx.fillStyle = (v===1)?'#5a4634' : (v===2?'#c2a678' : (v===3?'#136f8f' : '#d9c08a'));
        ctx.fillRect(x*T, y*T, T, T);

        // デコ
        if(v===4){ // 看板
          ctx.fillStyle='#b08968'; roundedRect(x*T+4,y*T+6,12,10,2,true);
          ctx.fillStyle='#784f2b'; ctx.fillRect(x*T+9,y*T+3,2,6);
        }
        if(v===5){ // サボテン（通行不可オブジェクト）
          ctx.fillStyle='#2f6f3a'; roundedRect(x*T+6,y*T+4,8,12,3,true);
          ctx.fillStyle='#2f6f3a'; roundedRect(x*T+3,y*T+8,6,6,3,true);
          ctx.fillStyle='#2f6f3a'; roundedRect(x*T+11,y*T+8,6,6,3,true);
        }
        if(v===3){ // オアシスの波
          ctx.fillStyle='#1a88ad'; ctx.fillRect(x*T+5,y*T+5,2,2);
          ctx.fillRect(x*T+12,y*T+10,2,2);
        }
      }
    }

    // インタラクト（砂丘の光）
    for(const it of interactables){
      if(it.type==='glow'){
        const t = performance.now()/300;
        const r = 6 + Math.sin(t)*2;
        ctx.beginPath();
        ctx.arc(it.x, it.y, r, 0, Math.PI*2);
        ctx.fillStyle='rgba(255,240,180,0.75)';
        ctx.fill();
      }
    }

    // NPC
    for(const n of npcs){
      drawChar(n.x,n.y,'#eab308'); // 黄
      if(dist(player,n)<TALK_RANGE){
        bubble(n.x, n.y-18, '話す');
      }
    }

    // プレイヤー
    drawChar(player.x, player.y,'#60a5fa');

    // 看板など近接表示
    for(const it of interactables){
      if(Math.hypot(player.x-it.x, player.y-it.y)<TALK_RANGE){
        bubble(it.x, it.y-18, it.name);
      }
    }

    drawToast();
  }

  function drawChar(x,y,color){
    ctx.save();
    ctx.translate(x,y);
    roundedRect(-10,-10,20,20,6,true,color);
    // 顔
    ctx.fillStyle='#0b1222';
    ctx.fillRect(-4,-2,2,2);
    ctx.fillRect( 2,-2,2,2);
    ctx.fillRect(-2,3,4,2);
    ctx.restore();
  }

  function bubble(x,y,txt){
    ctx.save();
    ctx.font='12px ui-sans-serif';
    const w = Math.max(42, ctx.measureText(txt).width+16);
    ctx.fillStyle='#0b1222cc'; roundedRect(x-w/2,y-16,w,18,6,true);
    ctx.strokeStyle='#1f2a44'; ctx.strokeRect(x-w/2,y-16,w,18);
    ctx.fillStyle='#cbd5e1'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(txt, x, y-7);
    ctx.restore();
  }

  function roundedRect(x,y,w,h,r,fill,color){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    if(fill){ ctx.fillStyle=color||ctx.fillStyle; ctx.fill(); }
  }

  // --- ループ開始 ---
  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();

  // --- 追加の“拾う”演出：砂丘の陰で断片を確定入手（演出のみ） ---
  function tryPickGlow(){
    for(const it of interactables){
      if(it.type==='glow' && Math.hypot(player.x-it.x, player.y-it.y)<TALK_RANGE){
        openDialog(it.name, [it.text], null);
        return true;
      }
    }
    return false;
  }
  const origTryTalk = tryTalk;
  tryTalk = function(){
    if(tryPickGlow()) return;
    origTryTalk();
  }

  // --- 初回ガイダンス ---
  if(!localStorage.getItem('urlhunt-first')){
    showToast('旅人に近づいて Space（または会話ボタン）で話しかけよう');
    localStorage.setItem('urlhunt-first','1');
  }

})();
</script>
</body>
</html>
